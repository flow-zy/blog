import{_ as n}from"./plugin-vue_export-helper-DlAUqK2U.js";import{o as s,c as a,f as t}from"./app-BGAn4IFu.js";const e={},o=t(`<div class="hint-container tip"><p class="hint-container-title">提示</p><p>ES6 中的 <code>async</code> 函数是一种特殊的函数，用于更方便地处理异步操作。函数前加上 <code>async</code> 关键字表示该函数是一个异步函数，并且它的返回值会被封装在一个 Promise 对象中。</p></div><h3 id="实现原理" tabindex="-1"><a class="header-anchor" href="#实现原理"><span>实现原理</span></a></h3><p><code>async/await</code> 的实现原理可以通过理解异步生成器（Async Generator）和 Promise 的工作原理来了解。下面是 <code>async/await</code> 的实现原理的简要解释：</p><ol><li><p><code>async</code> 函数的实现原理：</p><ul><li>当定义一个 <code>async</code> 函数时，它会被转化为一个返回 Promise 的普通函数。</li><li><code>async</code> 函数内部的 <code>await</code> 关键字会将其后面的表达式转化为一个 Promise 对象，并暂停函数执行，直到这个 Promise 对象被解决（完成）。</li><li>在函数暂停时，它会将控制权交回给调用方。</li><li>当 Promise 解决后，<code>async</code> 函数将从之前暂停的地方恢复执行，并返回解决的值。</li></ul></li><li><p><code>await</code> 表达式的实现原理：</p><ul><li><code>await</code> 表达式会暂停函数执行，直到传递给它的 Promise 对象被解决。</li><li>如果被传递的是一个原始值（非 Promise），它会被包装成一个已解决的 Promise 对象。</li><li>在等待期间，<code>await</code> 表达式的控制权会被传递回调用方。</li><li>一旦 Promise 被解决，<code>await</code> 表达式会从解决的 Promise 中提取结果，并将结果返回给调用方。</li></ul></li></ol><p>综上所述，<code>async/await</code> 通过将异步操作转化为 Promise，并使用 Promise 的解决（完成）机制来实现异步操作的流程控制。这样，我们可以将异步操作的代码看起来像是同步的，使得异步操作的编写和阅读更加直观、易懂。在内部，它仍然使用了事件循环和回调函数，但是通过 <code>await</code> 的语法糖，使得代码更具可读性和可维护性。</p><p><code>async/await</code> 是在 ES2017（ES8）引入的，它依赖于 Promise 和生成器功能，因此在运行环境中需要支持这些特性才能正常使用。</p><h3 id="特点和用法" tabindex="-1"><a class="header-anchor" href="#特点和用法"><span>特点和用法</span></a></h3><ol><li><p><code>async</code> 函数始终返回一个 Promise 对象：无论 <code>async</code> 函数的返回值是一个原始值、一个对象还是一个 Promise，它都会被自动封装在一个 Promise 对象中。如果 <code>async</code> 函数显式地使用 <code>return</code> 关键字返回一个值，该值将作为 Promise 对象的解决值；如果 <code>async</code> 函数抛出一个异常，那么 Promise 对象将会被拒绝，并将异常作为拒绝原因。</p></li><li><p><code>await</code> 关键字用于等待一个 Promise 对象的解决：在 <code>async</code> 函数内部，可以使用 <code>await</code> 关键字来等待一个异步操作的结果。<code>await</code> 关键字只能在异步函数内部使用，并且它会暂停函数的执行，等待 Promise 对象的解决（完成），然后返回 Promise 对象的值。在 <code>await</code> 关键字后面的表达式可以是一个 Promise 对象，也可以是一个非 Promise 值，如果是非 Promise 值，它会被包装为一个已解决（已完成）的 Promise 对象。</p></li><li><p><code>async</code> 函数内部可以包含一系列的异步操作：在 <code>async</code> 函数内部，可以使用常规的控制流语句（如 <code>if/else</code>、<code>for</code> 循环等），并使用 <code>await</code> 关键字来等待异步操作的结果。这使得异步代码的编写更加直观、易读。</p></li></ol><p>下面是一个使用 <code>async</code> 函数的示例：</p><div class="language-javascript line-numbers-mode" data-ext="js" data-title="js"><pre class="language-javascript"><code><span class="token keyword">function</span> <span class="token function">delay</span><span class="token punctuation">(</span><span class="token parameter">ms</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token parameter">resolve</span> <span class="token operator">=&gt;</span> <span class="token function">setTimeout</span><span class="token punctuation">(</span>resolve<span class="token punctuation">,</span> ms<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">async</span> <span class="token keyword">function</span> <span class="token function">fetchData</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&quot;Fetching data...&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token comment">// 模拟异步操作延迟</span>
  <span class="token keyword">await</span> <span class="token function">delay</span><span class="token punctuation">(</span><span class="token number">2000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token comment">// 模拟异步操作返回结果</span>
  <span class="token keyword">return</span> <span class="token string">&quot;Data fetched!&quot;</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">async</span> <span class="token keyword">function</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">try</span> <span class="token punctuation">{</span>
    <span class="token keyword">const</span> result <span class="token operator">=</span> <span class="token keyword">await</span> <span class="token function">fetchData</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&quot;Result:&quot;</span><span class="token punctuation">,</span> result<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span>error<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">error</span><span class="token punctuation">(</span><span class="token string">&quot;Error:&quot;</span><span class="token punctuation">,</span> error<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在上面的代码中，<code>fetchData</code> 是一个 <code>async</code> 函数，它使用 <code>await</code> 关键字等待异步操作的结果。<code>main</code> 函数也是一个 <code>async</code> 函数，它调用了 <code>fetchData</code> 并处理可能发生的异常。在 <code>main</code> 函数中，我们可以像同步代码一样使用 <code>await</code> 关键字来等待异步操作的结果。</p><p><code>async</code> 函数提供了一种更加优雅且易读的方式来编写和处理异步操作，使得代码的流程更加直观和易于维护。</p><ol start="4"><li>异步函数的错误处理：在异步函数中，可以使用 try-catch 块来捕获并处理异步操作中的错误。如果在异步函数中的任何地方抛出了一个异常，那么该异常将会被 Promise 对象拒绝，并可以通过 catch 块进行处理。</li></ol><div class="language-javascript line-numbers-mode" data-ext="js" data-title="js"><pre class="language-javascript"><code><span class="token keyword">async</span> <span class="token keyword">function</span> <span class="token function">fetchData</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">try</span> <span class="token punctuation">{</span>
    <span class="token keyword">const</span> response <span class="token operator">=</span> <span class="token keyword">await</span> <span class="token function">fetch</span><span class="token punctuation">(</span><span class="token string">&quot;https://api.example.com/data&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">const</span> data <span class="token operator">=</span> <span class="token keyword">await</span> response<span class="token punctuation">.</span><span class="token function">json</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> data<span class="token punctuation">;</span>
  <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span>error<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">error</span><span class="token punctuation">(</span><span class="token string">&quot;An error occurred:&quot;</span><span class="token punctuation">,</span> error<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">throw</span> error<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token comment">// 在调用异步函数时，可以使用 catch 块来捕获错误</span>
<span class="token function">fetchData</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
  <span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token parameter">data</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&quot;Data:&quot;</span><span class="token punctuation">,</span> data<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span>
  <span class="token punctuation">.</span><span class="token function">catch</span><span class="token punctuation">(</span><span class="token parameter">error</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">error</span><span class="token punctuation">(</span><span class="token string">&quot;Error:&quot;</span><span class="token punctuation">,</span> error<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>如果发生了错误，fetchData 函数中的 catch 块将捕获错误并进行处理。然后，通过使用 <code>then</code> 方法和相应的回调函数，以及 <code>catch</code> 方法捕获错误，从 Promise 对象中获得数据或者处理错误。</p><ol start="5"><li>多个异步操作的并行与顺序执行：使用 <code>await</code> 关键字，可以实现多个异步操作的并行或顺序执行。可以使用 <code>Promise.all</code> 方法将多个 Promise 对象封装成一个新的 Promise 对象，在 <code>await</code> 关键字后面等待这个新的 Promise 对象解决（即所有操作完成）。</li></ol><div class="language-javascript line-numbers-mode" data-ext="js" data-title="js"><pre class="language-javascript"><code><span class="token keyword">async</span> <span class="token keyword">function</span> <span class="token function">fetchMultipleData</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> <span class="token punctuation">[</span>data1<span class="token punctuation">,</span> data2<span class="token punctuation">,</span> data3<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">await</span> Promise<span class="token punctuation">.</span><span class="token function">all</span><span class="token punctuation">(</span><span class="token punctuation">[</span>
    <span class="token function">fetchDataFromAPI1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
    <span class="token function">fetchDataFromAPI2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
    <span class="token function">fetchDataFromAPI3</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
  <span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">return</span> <span class="token punctuation">[</span>data1<span class="token punctuation">,</span> data2<span class="token punctuation">,</span> data3<span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>fetchMultipleData 函数使用 <code>Promise.all</code> 将多个异步操作封装成一个 Promise 对象，并使用 <code>await</code> 关键字等待所有操作完成。然后，将每个异步操作的结果存储在变量中并返回。</p>`,18),c=[o];function p(i,l){return s(),a("div",null,c)}const r=n(e,[["render",p],["__file","async.html.vue"]]),k=JSON.parse('{"path":"/js/es/async.html","title":"Async","lang":"zh-CN","frontmatter":{"title":"Async","order":19,"category":"Javascript","description":"Async/Await","icon":"async","head":[["meta",{"property":"og:url","content":"https://github.com/newNotes/js/es/async.html"}],["meta",{"property":"og:site_name","content":"ZY 学习笔记"}],["meta",{"property":"og:title","content":"Async"}],["meta",{"property":"og:description","content":"Async/Await"}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2024-06-23T14:28:05.000Z"}],["meta",{"property":"article:author","content":"flow-zy"}],["meta",{"property":"article:modified_time","content":"2024-06-23T14:28:05.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"Async\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2024-06-23T14:28:05.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"flow-zy\\",\\"url\\":\\"https://flow-zy.github.io/newNotes/\\"}]}"]]},"headers":[{"level":3,"title":"实现原理","slug":"实现原理","link":"#实现原理","children":[]},{"level":3,"title":"特点和用法","slug":"特点和用法","link":"#特点和用法","children":[]}],"git":{"createdTime":1719152885000,"updatedTime":1719152885000,"contributors":[{"name":"overflow_z","email":"wz19121@eyeah.net","commits":1}]},"readingTime":{"minutes":4.76,"words":1427},"filePathRelative":"js/es/async.md","localizedDate":"2024年6月23日","excerpt":"<div class=\\"hint-container tip\\">\\n<p class=\\"hint-container-title\\">提示</p>\\n<p>ES6 中的 <code>async</code> 函数是一种特殊的函数，用于更方便地处理异步操作。函数前加上 <code>async</code> 关键字表示该函数是一个异步函数，并且它的返回值会被封装在一个 Promise 对象中。</p>\\n</div>\\n<h3>实现原理</h3>\\n<p><code>async/await</code> 的实现原理可以通过理解异步生成器（Async Generator）和 Promise 的工作原理来了解。下面是 <code>async/await</code> 的实现原理的简要解释：</p>"}');export{r as comp,k as data};
